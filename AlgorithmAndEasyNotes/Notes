Note on Boyer–Moore Majority Vote Algorithm and its variants 

| Variant                                             | Problem                                              | Max #Candidates | Algorithm Idea                                      | Verify Needed?           | Time                  | Space |
|-----------------------------------------------------|-------------------------------------------------------|------------------|------------------------------------------------------|---------------------------|------------------------|--------|
| 1. Majority Element (n/2, guaranteed)               | Find element > n/2 (guaranteed to exist).             | 1                | Cancel out minorities until majority remains.        | ❌ No (guarantee exists). | O(n)                   | O(1)   |
| 2. Majority Element II (n/3)                        | Find all elements > n/3.                              | 2                | Track 2 candidates, decrement counts when full.      | ✅ Yes.                   | O(n)                   | O(1)   |
| 3. Generalized Majority (n/k)                       | Find all elements > n/k.                              | k−1              | HashMap of ≤ (k−1) candidates, decrement all when full. | ✅ Yes.                   | O(n·k) / O(n) avg      | O(k)   |
| 4. Check if Majority Exists (n/2, not guaranteed)   | Return element if > n/2 exists, else -1.              | 1                | Boyer–Moore + verification.                          | ✅ Yes.                   | O(n)                   | O(1)   |
| 5. Mode (most frequent element)                     | Find element with max frequency (not threshold-based).| n possible       | Count all with HashMap.                              | ✅ Yes.                   | O(n)                   | O(n)   |

Tips 

Variant 1 (n/2, guarantee) → O(n), O(1).

Variant 2 (n/3) → 2 candidates.

Variant 3 (n/k) → at most (k-1) candidates.

Always verify counts unless majority is guaranteed.

---------------------------------------------------------------------------------------------------------------------------------------------

Variant 1 – Classic Majority Element (n/2)

Problem: Find element that appears > n/2 times (guaranteed to exist).

Key Idea: Only 1 candidate possible.

Steps:

Traverse array, maintain candidate + count.

If count = 0 → choose new candidate.

If same element → count++, else count--.

At end → candidate is answer (no verification needed if guarantee exists).


Example:

Input: nums = [3, 3, 4, 2, 3, 3, 3]
n = 7 → majority = more than 3.5 → ⌊7/2⌋ = 3
Output: 3
    
Code (Java):

class Solution {
    public int majorityElement(int[] nums) {
        int candidate = 0, count = 0;
        for (int num : nums) {
            if (count == 0) candidate = num;
            count += (num == candidate) ? 1 : -1;
        }
        return candidate; // guarantee exists
    }
}
---------------------------------------------------------------------------------------------------------------------------------------------
Variant 2 – Majority Element II (n/3)

Problem: Find all elements > n/3 times.

Max possible: 2 candidates.

Steps:

Track 2 candidates + counts.

Update counts like Boyer–Moore.

After first pass → verify counts.

Example:

Input: nums = [1, 2, 3, 1, 2, 1]
n = 6 → threshold = 6/3 = 2
Output: [1]

class Solution {
    public List<Integer> majorityElement(int[] nums) {
        int cand1 = 0, cand2 = 0, c1 = 0, c2 = 0;
        for (int num : nums) {
            if (num == cand1) c1++;
            else if (num == cand2) c2++;
            else if (c1 == 0) { cand1 = num; c1 = 1; }
            else if (c2 == 0) { cand2 = num; c2 = 1; }
            else { c1--; c2--; }
        }

        // verify
        c1 = c2 = 0;
        for (int num : nums) {
            if (num == cand1) c1++;
            else if (num == cand2) c2++;
        }

        List<Integer> res = new ArrayList<>();
        int n = nums.length;
        if (c1 > n / 3) res.add(cand1);
        if (c2 > n / 3) res.add(cand2);
        return res;
    }
}
---------------------------------------------------------------------------------------------------------------------------------------------
Variant 3 – Generalized Majority Element (n/k)

Problem: Find all elements > n/k times.

Max possible: k−1 candidates.

Steps:

Track up to (k−1) candidates in a map.

If new element and map full → decrement all counts.

Remove those with 0 count.

After pass → verify actual frequencies.

⚠ Note:

Cant remove directly in for-each loop → use:

Temporary list (toRemove) OR

Iterator with it.remove() (cleaner).

Variant 3: Generalized Majority (> n/k)

Example:

Input: nums = [1, 1, 2, 2, 3, 1, 2, 1], k = 4
Threshold = ⌊n/k⌋ = ⌊8/4⌋ = 2
Output: [1, 2]

Java code

class Solution {
    public List<Integer> majorityElement(int[] nums, int k) {
        Map<Integer, Integer> cand = new HashMap<>();
        
        for (int num : nums) {
            if (cand.containsKey(num)) cand.put(num, cand.get(num) + 1);
            else if (cand.size() < k - 1) cand.put(num, 1);
            else {
                Iterator<Map.Entry<Integer, Integer>> it = cand.entrySet().iterator();
                while (it.hasNext()) {
                    Map.Entry<Integer, Integer> e = it.next();
                    cand.put(e.getKey(), e.getValue() - 1);
                    if (cand.get(e.getKey()) == 0) it.remove();
                }
            }
        }

        // verify
        Map<Integer, Integer> freq = new HashMap<>();
        for (int num : nums) if (cand.containsKey(num))
            freq.put(num, freq.getOrDefault(num, 0) + 1);

        List<Integer> res = new ArrayList<>();
        for (int key : freq.keySet())
            if (freq.get(key) > nums.length / k) res.add(key);
        return res;
    }
}
----------------------------------------------------------------------------------------------------------------------------------------------
Variant 4  Check if Majority Exists (> n/2, no guarantee)

Problem: Return element if > n/2 exists, else return -1.

Steps:

Run Boyer Moore to get candidate.

Do verification pass to confirm.

Variant 4: Majority Check (> n/2, no guarantee)

Example:

Input: [1, 2, 3, 2, 2]
→ candidate = 2
→ count = 3 (> 5/2 = 2.5) 

Input: [1, 2, 3, 4]
→ candidate = 4
→ count = 1 

Output: -1

class Solution {
    public int majorityElement(int[] nums) {
        int candidate = 0, count = 0;
        for (int num : nums) {
            if (count == 0) candidate = num;
            count += (num == candidate) ? 1 : -1;
        }
        
        // verify
        count = 0;
        for (int num : nums) if (num == candidate) count++;
        return (count > nums.length / 2) ? candidate : -1;
    }
}
----------------------------------------------------------------------------------------------------------------------------------------------
Variant 5  Mode (most frequent element)

Different problem: Need element with highest frequency (no > n/k condition).

Solution: Use HashMap counting (O(n), O(n)).

⚡ Key Takeaways

Boyer Moore works because majority cancels out minorities.

For threshold n/k, at most k-1 candidates remain.

Always verify if the problem doesnt guarantee majority.

Map removal trick:

toRemove list (safe but extra storage).

Iterator with it.remove() (best).

Variant 5: Mode (most frequent element)

Example:

nums = [1, 2, 2, 3, 3, 3, 4]
Output: 3 (appears 3 times)

Java code
class Solution {
    public int modeElement(int[] nums) {
        Map<Integer, Integer> freq = new HashMap<>();
        int maxFreq = 0, mode = nums[0];
        for (int num : nums) {
            int f = freq.getOrDefault(num, 0) + 1;
            freq.put(num, f);
            if (f > maxFreq) { maxFreq = f; mode = num; }
        }
        return mode;
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------



